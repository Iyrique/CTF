# Image encrypter

_Difficult: hard_
## Описание работы python кода:

Программа считывает три аргумента командной строки, если они есть - 
запускается, если нет - валится с ошибкой.  

Программа представляет из себя скрипт питона, упакованный в _exe_
программой _pyinstaller_
Криптофункция работает по следующему алгоритму
1) Берется сид по времени запуска файла. Сид имеет вид (для примера):  
<code>2022-05-15 03:53:37.727301</code>
2) По этому сиду инициализируется рандом. Очевидно, что
используя один и тот же сид, получится одинаковый рандом
3) Далее код картинки бъется на блоки по длине ключа, блоки 
записываются в массив
4) Блоки в массиве перемешиваются, используя сид рандома, 
вычисленный ранее
5) Далее каждый блок побайтно ксорится с байтами ключа
6) Массив блоков сшивается в единый массив байтов
7) Полученный массив еще 10 раз кодируется алгоритмом _base64_

Далее полученный массив байтов записывается в файл
**encrypted_flag.jpg**

## Алгоритм решения

1) Разобрать exe до питон кода
2) Узнаем сид для инициализации рандома.
```shell
stat encrypted_flag.jpg 
16777234 34904775 -rw-r--r-- 1 devijoe staff 0 3841552 "May 15 07:17:41 2022" "May 15 06:53:37 2022" "May 15 07:17:40 2022" "May 15 06:53:37 2022" 4096 7504 0 encrypted_flag.jpg

```
Достаточно посмотреть 
на время создания файла картинки, чтобы понять, большую часть 
информации из сида:
`2022-05-15 06:53:37`
Помним, что UTS возвращает время по Лондону (+0), а мы 
живем по Московскому времени(+3), поэтому не забываем 
от времени создания отнять три.  
<code>2022-05-15 03:53:37.******</code>  
Звездочками заменены микросекунды, они нам неизвестны, но их
реально перебрать, всего _(10^6 - 1)_ вариантов.
4) Полезный факт: JPG формат (как и любой другой) имеет
свой заголовок, состоящий из 16 байтов
```
FF D8 FF E0 00 10 4A 46 49 46 00 01 01 00 00 01
```
4) Начнем восстановление файла: для начала нужно вернуть блоки 
на свое место. Для этого перебираем сид следующим видом:

`
SEED_PART = "2022-05-15 03:53:37."
MAGIC_BYTES_JPG = b'\xFF\xD8\xFF\xE0\x00\x10\x4A\x46\x49\x46\x00\x01\x01\x00\x00\x01'

def image_decrypter(data, seed_str):
    seed(seed_str, version=2)

    image1 = []
    for i in range(0, int(len(data) / 16) + 1):
        part = img[i * 16:(i + 1) * 16]
        image1.append(part)

    shuffle_table_indexes = [i for i in range(len(image1))]
    shuffle(shuffle_table_indexes)

    image2 = [0] * len(image1)
    for shuffle_index, original_index in enumerate(shuffle_table_indexes):
        image2[original_index] = image1[shuffle_index]

    m_bytes = image2[0]
    key = ''
    for b_i in range(len(m_bytes)):
        symbol = chr(m_bytes[b_i] ^ MAGIC_BYTES_JPG[b_i])
        if symbol in ascii_letters or symbol == '{' or symbol == '}':
            key += chr(m_bytes[b_i] ^ MAGIC_BYTES_JPG[b_i])
        else:
            return None
    return key

`
ХИНТЫ: 
    * Ключ состоит только из ASCI символов, "_", "{", "}"
    * Ключ имеет формат флага vrnctf{}, но это не флаг

Нужно перебирать все ключи, ксоря первые 16 байт картинки с MAGIC BYTES.
На выходе будет много картинок (хинтами можно сократить область поиска, но опять же, 
ключ хранится в txt файле, вряд ли там будут нечитаемые символы), одна из них будет нужная, 
но ключа там опять не будет


Проверить метаданные EXIF, там и будет флаг (или в binhex посмотреть).
Лучший сервис - https://www.imgonline.com.ua/
В поле "Имя владельца фотоаппарата" будет BASE64 строка:
dnJuY3Rme3kwdV9hcjRfZzBkXzBmX3A0dGgwbl9yZXZlNHNlfQ==

Флаг: vrnctf{y0u_ar4_g0d_0f_p4th0n_reve4se}